# -*- coding: utf-8 -*-
"""SecurePay Fraud Detector.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w5VPU06vL7CJXFrJeazLf6127k5T0bGd

# Importing Libraries
"""

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, precision_score, recall_score, f1_score, matthews_corrcoef, confusion_matrix

"""# Loading the Data"""

# Load the Data
data = pd.read_csv("/content/creditcard.csv")

"""# Understanding the Data"""

# Display the first few rows of the dataset
print("First few rows of the dataset:")
print(data.head())

# Display shape and statistical summary
print("\nShape of the dataset:", data.shape)
print("\nStatistical summary of the dataset:")
print(data.describe())

"""# Checking Class Distribution (Data Imbalance)"""

# Checking class distribution for imbalance in the data
fraud = data[data['Class'] == 1]
valid = data[data['Class'] == 0]
outlierFraction = len(fraud) / float(len(valid))

print("\nOutlier Fraction:", outlierFraction)
print("Fraudulent Transactions: {}".format(len(fraud)))
print("Valid Transactions: {}".format(len(valid)))

"""# Exploring Transaction Amounts"""

# Displaying amount details for fraudulent transactions
print("\nAmount details of the fraudulent transactions:")
print(fraud.Amount.describe())

# Displaying amount details for normal transactions
print("\nAmount details of the valid transactions:")
print(valid.Amount.describe())

"""# Plotting the Correlation Matrix"""

# Plotting the Correlation Matrix
print("\nCorrelation Matrix:")
corrmat = data.corr()
plt.figure(figsize=(12, 9))
sns.heatmap(corrmat, vmax=0.8, square=True)
plt.title('Correlation Matrix')
plt.show()

"""# Separating Features and Target Variable"""

# Separating the features (X) and the target variable (Y)
X = data.drop(['Class'], axis=1)
Y = data['Class']
print("\nFeatures shape:", X.shape)
print("Target shape:", Y.shape)

"""# Splitting the Data into Training and Testing Sets"""

# Splitting the data into training and testing sets
xTrain, xTest, yTrain, yTest = train_test_split(X, Y, test_size=0.2, random_state=42)
print("\nTraining set shape:", xTrain.shape)
print("Testing set shape:", xTest.shape)

"""# Handling NaN Values in the Target (if any)"""

# Handle NaN values in yTrain if any (not usually expected in this dataset)
indices = ~np.isnan(yTrain)
xTrain = xTrain[indices]
yTrain = yTrain[indices]

"""# Building and Training the Random Forest Model"""

# Create and train the Random Forest model
rfc = RandomForestClassifier(random_state=42)
rfc.fit(xTrain, yTrain)

"""# Making Predictions"""

# Make predictions
yPred = rfc.predict(xTest)

"""# Evaluating the Model"""

# Remove rows with NaN in yTest and corresponding xTest rows
indices = ~np.isnan(yTest)
yTest = yTest[indices]
xTest = xTest[indices]

# Now make predictions again if needed
yPred = rfc.predict(xTest)

# Evaluate the model
accuracy = accuracy_score(yTest, yPred)
print("Model Accuracy:", accuracy)

# Fill NaN values in yTest with the most common value (mode)
yTest = yTest.fillna(yTest.mode()[0])

# Make predictions again if needed
yPred = rfc.predict(xTest)

# Evaluate the model
accuracy = accuracy_score(yTest, yPred)
print("Model Accuracy:", accuracy)

"""# Calculating Other Metrics"""

# Calculating other metrics
precision = precision_score(yTest, yPred)
recall = recall_score(yTest, yPred)
f1 = f1_score(yTest, yPred)
mcc = matthews_corrcoef(yTest, yPred)

print("Precision:", precision)
print("Recall:", recall)
print("F1-Score:", f1)
print("Matthews Correlation Coefficient:", mcc)

"""# Visualizing the Confusion Matrix"""

# Confusion Matrix visualization
LABELS = ['Valid', 'Fraud']
conf_matrix = confusion_matrix(yTest, yPred)
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, xticklabels=LABELS, yticklabels=LABELS, annot=True, fmt='d', cmap='Blues')
plt.title("Confusion Matrix")
plt.xlabel('Predicted Class')
plt.ylabel('True Class')
plt.show()